#!/usr/bin/env ruby

require 'getoptlong'
require 'fileutils'

REPO = File.expand_path(File.join(__dir__, '../')).freeze

$database = {
  name: ENV.fetch('LITTLESIS_DATABASE_NAME', 'littlesis'),
  user: ENV.fetch('LITTLESIS_DATABASE_USER', 'littlesis'),
  password: ENV.fetch('LITTLESIS_DATABASE_PASSWORD', 'themanbehindthemanbehindthethrone'),
  host: ENV.fetch('LITTLESIS_DATABASE_HOST', 'postgres')
}

$rails_env = ENV.fetch('RAILS_ENV', 'development')
$deploy_branch = 'main'

def help
  puts <<TEXT
Usage: littlesis [options] <command> [--] [arguments for command]

Commands
           docker           run any docker-compose comand
           up               start docker containers
           down             stop docker containers
           delete           deletes database by removing docker volumes
           build            build littlesis docker image
           bash             interative bash shell
           console          launch rails console
           redis            launch redi cli

LittleSis
          data              ETL utilities for external data
          fec               runs FEC data cli
          deploy            deploys to latest commit on main

Aliases:  bundle, pumactl, rspec, rails, yarn, git rg

TEXT
end

def database_connection
  "postgresql://#{$database[:user]}:#{$database[:password]}@#{$database[:host]}/#{$database[:name]}"
end

def setup_folders
  %w[tmp data data/external_data data/external_data/original data/external_data/csv public/oligrapher public/images
     public/images/large public/images/original public/images/profile public/images/small public/images/oligrapher].each do |folder|
    FileUtils.mkdir_p File.join(REPO, folder)
  end
end

def docker_compose(*args)
  Dir.chdir(REPO) do
    exec "docker-compose #{args.join(' ')}"
  end
end

def app_exec(cmd, bin: false, run: false)
  bin_path = $rails_env == 'production' ? '/var/www/littlesis/bin' : '/littlesis/bin'
  cmd = "#{bin_path}/#{cmd}" if bin

  if $rails_env == 'production'
    Dir.chdir(REPO) do
      if run
        exec cmd
      else
        puts `#{cmd}`
      end
    end
  else
    if run
      docker_compose 'run', '--rm', "-e RAILS_ENV=#{$rails_env}", 'app', cmd
    else
      docker_compose 'exec', "-e RAILS_ENV=#{$rails_env}", 'app', cmd
    end
  end
end

def app_exec_bin(cmd)
  app_exec(cmd, bin: true)
end

def git(cmd)
  Dir.chdir(REPO) { `git #{cmd}` }
end

def systemd_service_check(service)
  status = system("systemctl is-active -q #{service}") ? '✓' : 'X'
  puts "[#{status}] #{service}"
end

def status
  current_commit = git("rev-parse --short HEAD").chomp
  current_branch = git("rev-parse --abbrev-ref HEAD").chomp

  puts "commit #{current_commit} on branch #{current_branch}"
  puts "Rails Environment \033[1m#{$rails_env}\033[0m"

  if $rails_env == 'production'
    systemd_service_check 'littlesis'
    systemd_service_check 'littlesis-goodjob'
    systemd_service_check 'redis'
    systemd_service_check 'nginx'
    app_exec_bin 'rake ts:status'
  else
    running_services = Dir.chdir(REPO) { `docker-compose ps --services --filter status=running` }.split("\n")

    %w[redis postgres app nginx].each do |service|
      puts "[#{running_services.include?(service) ? '✓' : 'X'}] #{service} "
    end
  end
end

def deploy
  raise "Cannot deploy unless mode = production" unless $rails_env == 'production'

  Dir.chdir(REPO)

  modified_files = git("ls-files -m").split("\n")

  if modified_files.count.positive?
    puts "The following files have been modified:\n#{modified_files.join("\n")}"
    puts "Are you sure you want to deploy? (y/n)"
    exit 1 unless $stdin.gets.strip.casecmp('y').zero?
  end

  puts "deploying branch #{$deploy_branch}"
  git("fetch origin #{$deploy_branch}")

  remote_commit = git("rev-parse \"origin/#{$deploy_branch}\"").chomp
  local_commit = git("rev-parse @").chomp

  if remote_commit == local_commit
    puts "No upstream changes"
    exit
  end

  git_subject = git("log --format=%s -n 1 \"#{remote_commit}\"")
  puts "Deploying #{remote_commit}: #{git_subject}"
  git("checkout $deploy_branch")
  git("pull")

  changed_files = git("diff --name-only #{remote_commit} #{local_commit}").split("\n")

  if changed_files.any? { |f| f.include?('db/migrate') }
    puts <<-MSG
      +-----------------------------------------------------------+
      These changes likely require a database update,
      which will NOT happen automatically by this script.
      To perform a migration run: "littlesis -P rake db:migrate"
      +-----------------------------------------------------------+
    MSG
  end

  if changed_files.include?('Gemfile') || changed_files.include?('Gemfile.lock')
    app_exec_bin 'bundle install'
  end

  if changed_files.include?('yarn.lock')
    app_exec_bin 'yarn'
  end

  # TODO detech changes to Rails.application.config.littlesis.oligrapher_commit and run OligrapherAssetsService.run

  if changed_files.include?('yarn.lock') || changed_files.any? { |f| f.include?('assets') || f.include?('javascript') }
    app_exec_bin 'rake assets:precompile'
  end

  puts "Restarting LittleSis"
  app_exec_bin 'pumactl -p tmp/puma.pid restart'
end

opts = GetoptLong.new(
  ['--help', '-h', GetoptLong::NO_ARGUMENT],
  ['--test', '-t', GetoptLong::NO_ARGUMENT],
  ['--development', '-d', GetoptLong::NO_ARGUMENT],
  ['--production', '-P', GetoptLong::NO_ARGUMENT],
  ['--branch', GetoptLong::REQUIRED_ARGUMENT]
)

def set_env_to_test
  $rails_env = 'test'
  $database[:name] = 'littlesis_test'
  ENV['RAILS_ENV'] = $rails_env
end

opts.each do |name, val|
  case name
  when '--help'
    help
    exit
  when '--test'
    set_env_to_test
  when '--development'
    $rails_env = 'development'
  when '--production'
    $rails_env = 'production'
  when '--branch'
    $deploy_branch = val
  end
end

ENV['RAILS_ENV'] = $rails_env

if ARGV.empty?
  help
  exit
end

rest = ARGV[1..].join(' ')

case ARGV.first
when 'help'
  help
when 'setup-folders'
  setup_folders
when 'docker', 'docker_compose', 'docker-compose'
  docker_compose rest
when 'up'
  docker_compose 'up -d'
when 'down'
  docker_compose 'down'
when 'delete'
  docker_compose 'down -v'
when 'build'
  Dir.chdir(REPO) { exec "docker build -t littlesis:latest ." }
when 'pumactl'
  app_exec_bin "pumactl -p tmp/puma.pid #{rest}"
when 'test', 'rspec'
  set_env_to_test
  app_exec_bin "rspec #{rest}"
when 'rails'
  app_exec_bin "rails #{rest}"
when 'bundle'
  app_exec_bin "bundle #{rest}"
when 'yarn'
  app_exec_bin "yarn #{rest}"
when 'rake'
  app_exec_bin "rake #{rest}"
when 'runner'
  app_exec_bin "rails runner #{rest}"
when 'bash'
  app_exec "/bin/bash --login #{rest}"
when 'console', 'c'
  app_exec "rails c #{rest}", bin: true, run: true
when 'redis'
  app_exec "/usr/bin/redis-cli -h redis"
when 'data'
  app_exec_bin "rails runner lib/scripts/data.rb #{rest}"
when 'fec'
  app_exec_bin "rails runner lib/scripts/fec.rb #{rest}"
when 'git'
  puts git(rest)
when 'rg', 'search'
  Dir.chdir(REPO) { exec "rg #{rest}" }
when 'psql', 'pg_dump', 'pg_restore'
  docker_compose 'run --rm postgres', ARGV.join(' '), database_connection
when 'status'
  status
when 'deploy'
  deploy
else
  puts "Invalid Command: #{ARGV.first}"
  exit 1
end
